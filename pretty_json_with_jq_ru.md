# Человекочитаемый json с помощью jq

```
{
    "date_time_msk" : "2018-02-11 20:44"
}
```

Для работы с json есть весьма популярная утилита командной строки jq

С помощью этой утилиты очень просто из json, написанного в одну строчку
сделать json который удобно читать.

Пример:

    $ echo '{"a":"a","d":{"e":88},"b":[],"c":false}' | jq .
    {
      "a": "a",
      "d": {
        "e": 88
      },
      "b": [],
      "c": false
    }

В тексте не видно, но jq еще и подсвечивает элементы json разными цветами. Вот скриншот:

![Скриншот использования jq](https://upload.bessarabov.ru/bessarabov/gHj0T6486fGp14ljeQI1IF0zFu8.png)

По умолчанию jq отображает ключи в точно таком же порядке, как они были в
изначальном json. Обычно удобнее смотреть на json, ключи которого отсортированы.
Для этого у jq есть параметр --sort-keys (и есть сокращенная форма для этого параметра -S ):

    $ echo '{"a":"a","d":{"e":88},"b":[],"c":false}' | jq -S .
    {
      "a": "a",
      "b": [],
      "c": false,
      "d": {
        "e": 88
      }
    }

В этих примерах видно что если указан параметр -S, то в json объекте ключи отсортированы: a, b, c, d.
А если ключ -S не указан, то ключи идут в том же порядке, как в изначальном json: a, d, b, c.

Вообще, jq — это достаточно сложная штука, с помощью которой можно много чего сделать с json.
На вход jq приходят json или несколько json-ов, к ним применяется фильтр и jq отображает результат
работы этого фильтра. Самый простой фильтр — это точка. Фильтр "точка" никак не изменяет входные
данные. Во всех примерах в этом тексте как раз использовался фильтр точка.

Вообще, если у вас версия jq 1.5, то точку можно и не указывать, если json приходит на вход jq:

    $ echo '{"a":"a","d":{"e":88},"b":[],"c":false}' | jq
    {
      "a": "a",
      "d": {
        "e": 88
      },
      "b": [],
      "c": false
    }

Но если у вас более ранняя версия jq, то нужно обязательно указывать фильтр.

Если вы не подаете данные на вход, а передаете jq файл который нужно обработать,
то в этом случае фильтр нужно указать обязательно. Вот так работает:

    $ cat a.json
    {"a":"a","d":{"e":88},"b":[],"c":false}
    $ jq . a.json
    {
      "a": "a",
      "d": {
        "e": 88
      },
      "b": [],
      "c": false
    }

А без указания фильтра — не работает:

    $ jq a.json
    jq: error: a/0 is not defined at <top-level>, line 1:
    a.json
    jq: 1 compile error

Вот пример более сложного фильтра. Тут создается новый json документ, значения которого —
это некоторые значения изначального json.

    $ echo '{"a":"a","d":{"e":88},"b":[],"c":false}' | jq '{ aa : .a, bb : .b }'
    {
      "aa": "a",
      "bb": []
    }

(но вообще, фильтры в jq — это отдельная большая тема)

На macOS jq можно установить с помощью команды:

    brew install jq

(Для того чтобы эта команда сработала нужно сначала установить [Homebrew](https://brew.sh/).)
